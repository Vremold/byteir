diff --git a/lib/Dialect/Torch/Transforms/LowerToBackendContract.cpp b/lib/Dialect/Torch/Transforms/LowerToBackendContract.cpp
index d40f9906..e4fe97c2 100644
--- a/lib/Dialect/Torch/Transforms/LowerToBackendContract.cpp
+++ b/lib/Dialect/Torch/Transforms/LowerToBackendContract.cpp
@@ -30,6 +30,46 @@ using namespace mlir::torch::Torch;
 // Checking the backend contract.
 //===----------------------------------------------------------------------===//
 
+static void markDynamicShapeOpAsIllegal(ConversionTarget &target) {
+  auto isConstantIntFloatValue = [](Value v) -> bool {
+    return llvm::isa<ConstantIntOp>(v.getDefiningOp()) ||
+           llvm::isa<ConstantFloatOp>(v.getDefiningOp());
+  };
+  auto isListOfConstantIntValue = [](Value v) -> bool {
+    SmallVector<int64_t> values;
+    if (!matchPattern(v, m_TorchListOfConstantInts(values))) {
+      return false;
+    }
+    return true;
+  };
+  target.addDynamicallyLegalOp<AtenArangeStartStepOp>(
+      [&](AtenArangeStartStepOp op) {
+        auto outputType = op.getResult().getType().cast<BaseTensorType>();
+        Value start = op.getStart();
+        Value end = op.getEnd();
+        Value step = op.getStep();
+
+        if (isConstantIntFloatValue(start) && isConstantIntFloatValue(end) &&
+            isConstantIntFloatValue(step)) {
+          if (!outputType.areAllSizesKnown()) {
+            return false;
+          }
+        }
+        return true;
+      });
+  target.addDynamicallyLegalOp<AtenViewOp>([&](AtenViewOp op) {
+    auto outputType = op.getResult().getType().cast<BaseTensorType>();
+    Value size = op.getSize();
+
+    if (isListOfConstantIntValue(size)) {
+      if (!outputType.areAllSizesKnown()) {
+        return false;
+      }
+    }
+    return true;
+  });
+}
+
 static void markDecomposedOpsAsIllegal(MLIRContext *context,
                                        ConversionTarget &target,
                                        llvm::StringSet<> backendLegalOps);
@@ -251,6 +291,7 @@ getBackendContractTarget(MLIRContext *context, bool decompose,
                          llvm::StringSet<> backendLegalOpsSet) {
   ConversionTarget target(*context);
   target.addLegalDialect<func::FuncDialect, Torch::TorchDialect>();
+  markDynamicShapeOpAsIllegal(target);
   if (decompose)
     markDecomposedOpsAsIllegal(context, target, backendLegalOpsSet);
   return target;
@@ -386,6 +427,7 @@ static void markDecomposedOpsAsIllegal(MLIRContext *context,
   target.addIllegalOp<Aten_SoftmaxBackwardDataOp>();
   target.addIllegalOp<AtenTanhBackwardOp>();
   target.addIllegalOp<AtenAddmmOp>();
+  target.addIllegalOp<AtenEinsumOp>();
   target.addIllegalOp<AtenMeanOp>();
   target.addIllegalOp<AtenMeanDimOp>();
   target.addIllegalOp<AtenNormScalarOptDimOp>();
